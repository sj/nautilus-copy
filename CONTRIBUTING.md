
# Nautilus Contribution Guidelines

We are happy to have contributors to our project. If you'd like to contribute
a feature, bug fix, or other component to Nautilus, we ask that you first read these
guidelines.

## Table of Contents
- [How Can I Contribute?](#how-can-i-contribute)
- [Development Model](#development-model)
- [Styleguide](#styleguide)


## How Can I Contribute?

### Reporting Bugs
You can report bugs in the issue tracker for the
Github page. Make sure to label the issue appropriately, 
and provide a verbose description which outlines in detail
everything necessary for us (or others) to reproduce the
bug. This includes:

1. Your development environment (which version of `gcc`, what
host are you compiling on? 
2. How did you compile Nautilus? You can even attach your `.config` file
(generated by running `make menuconfig` so we can know which exact
configuration you're using.
3. Your runtime environment: if running with `qemu`, which flags
did you provide. If you're running on bare hardware, what are the
hardware specs? (i.e. CPU architecture, vendor, how much RAM, which
BIOS etc.)
4. What features did you add or what changes did you make? Is this
code you've added? Did you tweak the `Makefile`?
5. Is the bug deterministic? If not, under what conditions does it seem
most likely to arise?

### Creating an Issue
We've set up several labels to organize issues into logical groups. 
For example, if it is a bug that you're filing, label your issue
with the `bug` label. Use every appropriate label from the list. We've
created a few custom labels of interest:

* `bug`: Something is broken.
* `beginner`: This is an issue or feature that a newcomer would
likely be able to work on.
* `compilation`: This is an issue specific to compilation and
the build process.
* `documentation`: This is an issue that only relates to commenting
or documentation.
* `hardware only`: This issue only affects bare hardware, not virtual environments.
* `virtual only`: This issue only relates to virtual environments, e.g. QEMU or KVM.
* `hardware + virtual`: The issue is relevant to both physical and virtual hardware.
* `runtime`: The issue relates to a particular runtime system, not Nautilus itself.
* `enhancement`: Used for feature requests (wish list items).
* `question`: General questions and inquiries.


### Your First Code Contribution
Follow the process below, and submit a pull request.



## Development Model

### Getting Started
When developing with Nautilus, it's best to get a good dev environment
set up first, e.g. using a personal Linux box or VM with QEMU installed, or
a physical machine which you can control via serial port or BMC (e.g.
with [IPMI + PXE boot](http://cs.iit.edu/~khale/docs/notes/pxe-server.html) 
or with [PXE boot and a serial cable](http://cs.iit.edu/~khale/docs/notes/pxe.html)).

We've provided a default `Vagrantfile` to use with [Vagrant](https://www.vagrantup.com/) for
rapid development. See more in the [README](https://github.com/HExSA-Lab/nautilus/blob/master/README.md).

### Contributing Code
You'll first want to make sure you have a Github account. Then, head
over to the [Nautilus github page](https://github.com/HExSA-Lab/nautilus.git)
and use the **fork** feature. Now, on your dev machine, you can clone like so:

    git clone git@github.com:USERNAME/nautilus.git

### Keeping Your Fork Synchronized

Unless you're planning on submitting a quick fix, you'll want to make sure that
your fork is up to date with our `master` branch. You can do this with _upstream_
tracking:

    # Add upstream to the list of remotes
    git remote add upstream https://github.com/HExSA-Lab/nautilus.git

    # Verify that the new remote is added
    git remote -v

Now, whenever you want to make sure your fork is up to date with the latest
upstream changes, you'll first fetch all the upstream branches:

    # Fetch from upstream
    git fetch upstream

    # Look at all branches, including those from upstream
    git branch -va

Now, checkout your _own_ master branch and merge it with the upstream's
master branch:

    git checkout master
    git merge upstream/master

If there are no unique commits on your _local_ master branch, Git will just
do a fast-forward here. If you have been making changes on master (you probably shouldn't be,
see [below](#adding-your-own-features)), you might have to fix some merge conflicts when
you do this. When doing so, be careful to respect the upstream changes. 

At this point, you should be in sync with everything on the upstream.

### Adding Your Own Features
When you start working on a new feature, enhancement, or bugfix, it is important
that you start doing so in a **new branch**. This adheres to the standard Git workflow
and makes it easy to logically separate different components/tasks you're working on
and makes them easy to submit to the mainline codebase (using [pull requests](#submitting-a-pull-request)) when you finish and have them
in an acceptable state. For example, if I'm implementing a new device driver for a newfangled Footrix NIC, I would do as follows from
a fresh fork:

    # We want our changes to be based on master
    git checkout master

    # Come up with a meaningful name for our new branch, related to the work we're doing
    git branch footrix-nic

    # Switch to the new branch
    git checkout footrix-nic

Now have fun building!


### Getting Ready for a Pull Request

To submit work to the main codebase, we use a **pull request**. The name is somewhat misleading, as it's not
at all related to a `git pull`. This is essentially a request to have your code merged in. Before you do so,
however, it's a good idea to do some cleanup that will make it easier for the maintainers to 
merge in your code. The most important thing is to integrate any changes that have been made into the upstream
since you started your work. This will avoid annoying conflicts and make the merging process essentially
the same as a fast-forward. To do this, we **rebase** on top of the mainline branch:

    # Fetch from the upstream mainline branch, and merge with *your* repo's master
    git fetch upstream
    git checkout master
    git merge upstream/master

    # If we got new commits from the upstream, we'll now rebase on top of them
    # by taking our commits whole sale and placing them back on top of our master branch.
    # (again, assuming the same branches as above)
    git checkout footrix-nic
    git rebase -i master


If you've made a lot of very small commits, it might make sense to collapse them into
one larger commit with everything logically related. In Git, we call this "squashing." 
We can do this _during_ the rebase using the interactive (`-i`) mode:

    # Rebase all commits made on our footrix-nic branch
    git checkout
    git rebase -i master

This will open up in your default text editor from which you can pick commits to
squash together. 

### Submitting the Pull Request

Now that you've finished your work, you can submit a pull request. First, you should make
sure to commit all your changes (as above) and then push them to *your* Github fork.

    # push to my dev branch
    git push origin footrix-nic


Now, go to the page for your Github fork, and select the appropriate branch. You
can then click the "pull request" button. If you need to make changes after
submitting the pull request, don't worry; the pull request will track new changes
as you push them to the branch for which you created the request.

## Styleguide

### C coding style

"The use of equal negative space, as a balance to positive space, in a
composition is considered by many as good design. This basic and often
overlooked principle of design gives the eye a "place to rest,"
increasing the appeal of a composition through subtle means."
Translation: Use the spacebar liberally, and make sure your
indentation lines up!

#### Errors and Failstops
Because booting a kernel involves many, many steps, catching silent errors is next to impossible. 
For this reason
**any** time your code has an error it should return -1 (or `NULL`), and expect the
execution to halt. If the function you're implementing is critical to the system
as a whole, consider using `panic()`.

This includes unimplemented features and unhandled cases. These cases
should **always** return -1 (and ideally do something like the following).

```C
ERROR_PRINT("UNIMPLEMENTED (%s)\n", __func__);
```

#### Variable Names
Try to make variable names short and concise, but
unambiguous. 

```C
int network_packet_count;
```

is very clear, but too long.

```C
int npc;
```

is concise but conveys no meaning.

```C
int net_pkt_cnt;
```

is preferable because it uses abbreviations to 
make the name precise, but the intent is still clear.

#### Function Names
To ease porting, externally visible function names should be used rarely and
have unique names. Currently we have two techniques to achieve this:

1. **`static` functions**: Any utility functions that are only needed in the .c
file where they are defined should be declared as static and **not** included
in the header file. 

2. **`nk_` prefix**: Major interface functions should be named with the prefix
`nk_`. This allows easy understanding of how to interact with the subsystems.
In the case that they're interfacing with some external runtime system or
library, it decreases the probability that they will collide with other
functions.

#### Design

Generally you should try to make your code as general and reusable as possible. 
You should try to separate things out into separate functions when applicable, and
carefully considering performance implications. See [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself).

#### Performance

Please be cognizant of page size and cache effects when you write performance critical code. 

For example, if you write a data structure, some component of which you know will be shared, consider
aligning entries on a cache line. E.g. instead of:

```C
    struct perf_critical {
        int a;
        int b;
        uint8_t data_buf[SIZE];
     };
```
do this:

```C
    struct perf_critical {
        int a;
        int b;
        uint8_t data_buf[SIZE] __attribute__((aligned(L1_LINE_SIZE)); // usually 64 bytes
    };
```

#### Function style

We prefer `glibc` style function headers with return types on
separate lines as the function name, e.g.:

```C
    static inline int
    foo (int arg1, int arg2)
    {
        return 0;
    }
```
not this:
```C
    static inline int foo(int arg1,int arg2) {
        return 0;
    }
```
Note the liberal use of whitespace here (and the space before the parameter
list).  The opening bracket comes on the line *after* the parameter list to
look more symmetric.

#### Commenting

In general, prefer multiline comment syntax with `*`s added
to extra lines. E.g., this:
```C
    /*
     * This is a comment for a function.
     * It uses proper alignment and does not
     * trail on too long for any individual line.
     */
    int foo (void)
    {
        return 0;
    }
```
not this:
```C
    // this comment is not proper style for Nautilus. It runs on too long in 
    // an individual
    // line and does not maintain balance. Furthermore, it uses
    // the single-line comment format. If you're a VIM user, consider
    // using visual select followed by gq to automatically balance
    // subsequent lines.
    int foo(void) { return 0;}
```

#### Conditionals

Prefer this:
```C
    if (cond == 0) {
        a++;
    }
    foo(a);
```
over this:
```C
    if (cond == 0) 
        a++
    foo(a);
```
#### Debugging Output
Debugging output can be added when you're developing but do not want prints to
appear when the code is running regularly.

Two functions of note are `ERROR_PRINT` and `DEBUG_PRINT`

`DEBUG_PRINT`:
Should be used for debugging output that will often be
turned off selectively by the kernel configuration.

`ERROR_PRINT`:
Should be used when an error occurs, this will never be optimized out
and will always print. 

### Git commit messages

* Use the present tense ("add feature" not "added feature")
* Use the imperative mood ("move driver registration to" not "moves driver registration to")
* Limit the first line to less than 80 characters
* Be verbose after the first line, making sure to reference specific issues and pull requests
* Be sure to set up your Git environment properly so that your name and e-mail 
appear properly in the commit message. If you have a university affiliated e-mail, prefer that
one over personal e-mails. Pull requests or patchsets that have improper e-mails or 
names (e.g. Author: root@root.com) will be rejected.
* If you have GNU privacy utilities install (i.e., `gpg`), sign commits with your
PGP key when possible (using
`git commit -S`)
* For multiple-author commits, adhere to the following style
    ```Shell
    git commit --author="John Doe, Sam Smith, and Brian Bootloader <jdoe,ssmith,bboot@cs.univ.edu>"
    ```




